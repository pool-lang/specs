{"ts":1347632245277,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"Functions\n\n\n%!includeconf: config.t2t\n\n== Basic ==\n\nA function takes a tuple of values and returns a tuple of values.  A function\nis a block bound to a name.\n\n== Declaration ==\n\n```\n\t[[ (uint16, uint16) split ( i:uint32 ):\n\t\treturn ( i >> 16, i & 0xFFFF );\n\t]]\n\n\t// inside a function only\n\tvar makeBigger = [[(real v); v + 1.43 ]]; // return type is inferred to be real.\n```\n\nThe first thing inside the delimiter is the function signature.  It is optinal and\nends with a colon.  The colon is not nessary if it is omitted.\n\nTo the left side of the function name is the return tuple.  The name can begin\nwith any alphabetic character or an underscore and contain any alphanumeric\ncharacters as well as underscores.  The name can be ignored if the function is\nbeing used (assigned to a delegate or passed to a function).  Anonymous functions\nmay also omit the arguments and return tuples in which case the return types\nwill be inferred and the function will take no arguments.  If there is one tuple\npresent it will be assumed to be the arguments.  If an anonymous function is\nbeing created inside the argument list of a function the types of the arguments\nmay be omitted and they will be the types that the parameter specifies in it's\ndefinition.\n\nA function will return the value of the last statement executed.  If you wish to\nreturn a value earlier you can use a return statement.  The return statement\nwill return the values passed to it.\n\n=== Blocks ===\n\nBlocks are similar to functions, the main difference is that blocks  have the\nadded advantage of having access to the scope of the enclosing function.  Also\nyou cannot return from a block.  Return statements inside blocks will return\nfrom the enclosing function. Blocks cannot be bound to a name accessable outside\nof the function they are declared in.  Therefore if ``filter`` in the following\nexample attempts to store the delegate passed to it, this will fail to compile.\n\nThe rules for defining blocks are nearly identical to functions except you use\n``{`` and ``}`` instead of ``[[`` and ``]]``.\n\n```\n\tset.filter({(i): i % 2 == 0 });\n\n\tvar pivot = 8;\n\tset.filter({(i): i > pivot });\n```\n\n=== Default Arguments ===\n```\n\t[[ (a:Collection) collectionMin ( a:Collection, min :int = 10 ):\n\t\ta.map({(i:int): i > min ? i : min });\n\t]]\n```\n\nDefault arguments are the value that should be passed if an argument is not\nspecified by the caller.  If any argument has a default value all the arguments\nto the right of it must also have a default value.  Default values may refer to\nanything that can be accessed from the location of the function declaration and\nany previous arguments.\n\n=== Named return values ===\n```\n\t{ (r:String) createString ( in:Collection!String ):\n\t\tr = \"\"\n\n\t\tin.foreach([[(s:String);\n\t\t\tr += s;\n\t\t]])\n\t}\n```\n\nNamed return values allow you to use a value inside a function and it will\nautomatically be returned at the end.  The type of a named return value must be\na class.  The value will not be initialized.  If any return value has a name all\nreturn values to the right of it must also have a name.  If you use a return\nstatement you do not need to provide values for the named items.  If the name\nof a return value is the same as that of an argument the value will be\ninitialized with the value passed in.\n\n=== Macros ===\n\nPool does not have explicit macros but you can use local blocks or functions as\nmacros.\n```\n\t{ @unittest:\n\n\t\t[[ (bool) isCloseF(f1:real, f2:real, tol:real = 0.001):\n\t\t\treturn f1+tol > f2 && f1-tol < f2;\n\t\t]]\n\t\t{ (bool) isCloseB(f1:real, f2:real, tol:real = 0.001):\n\t\t\tf1+tol > f2 && f1-tol < f2;\n\t\t}\n\n\t\tassert(isCloseF(sin(Pi*0.0, 0)));\n\t\tassert(isCloseF(sin(Pi*0.5, 0)));\n\t\tassert(isCloseB(sin(Pi*1.0, 0)));\n\t\tassert(isCloseB(sin(Pi*1.5, 0)));\n\t}\n```\n\n== Calling ==\n```\n\tvar i = sin(Pi/2);\n```\n\nFunction calls are similar to most C-style languages.  It is the name of the\nfunction followed by a tuple of arguments.\n\n=== Syntax Sugar ===\n\n==== Block Outside Function Call Syntax ====\n\nIf the last argument of a function is a block or anonymous function you may\nput it outside of the brackets and the semi-colon can be omitted.\n\n```\n\t[[ () f ( i :int, f :{(int)(int)} );\n\t\t// ...\n\t]]\n\n\tf(5, {(i): i*2 });\n\t// can be written as:\n\tf(5)\n\t\t{(i): i*2 }\n\n\t// This is really nice when the block takes no arguments.\n\tif (true, {i++});\n\t// can be written as:\n\tif (true) {i++}\n```\n\n== Getter and Setter Functions ==\n\nModern programming practices frown upon public variables.  This creates many\nfunctions such as ``getValue()`` and ``setValue()``.  This causes a lack of\nmember variables and a waste of beautiful syntax.  Pool allows you to write\nsetters and getters and they can act just like regular variables.  This adds\nmeaning and elegance to code.  These are compatiable with regular assignment so\nyou can start of with public variables and switch them to getters and setters\nwhen you need them and code that uses them will only need a recompile.\n\n```\n// If you have this:\npublic var randomNumber = 4; // chosen by fair dice role.\n                             // guaranteed to be random.\n\n// And you later decide you want an actually random number you can change it\n// to this:\nvar source = RandomGenerator(4);\n@property @public [[randomNumber: source.get() ]]\n// No setter -- How can you set a random number?\n```\n\nThe syntax for a getter is the ``@property`` tag, followed by the function\ndefinition.  If it does not take any arguments it can be called as a getter.\n\nThe syntax for a setter is the ``@property`` tag, followed by the function\ndefinition.  It must take arguments.  If there are no values in the return tuple\nthen the assignment can't be used as a right-hand value.\n\n```\n\tvar r = randomNumber;\n\trandomNumber = 3; // Error: setter not defined.\n```\n\nAlthough this example is not the best useage of property functions it clearly\nillistrates many benifits.  When writing property functions it is recommended\nthat you follow the below guidelines so that your code makes sense to a new\nreader.\n\n - Calling the getter multiple times should yield the same result and keep the\n\tobject that it was called on semanticaly the same.\n - The setter should return the value passed to it.\n - Many people will expect that getters are not expensive.  It is often a good\n\tidea to cache the values so that repeated calls are cheep.\n\nIn general try to use property functions when the function acts like a regular\nvariable.\n\n"]],"start1":0,"start2":0,"length1":0,"length2":6412}]],"length":6412}
